<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html> 

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <title>CL-GLFW - A CL binding for GLFW</title>
  <style type="text/css">
  pre { padding:5px; background-color:#e0e0e0 }
  h3, h4 { text-decoration: underline; }
  a { text-decoration: none; padding: 1px 2px 1px 2px; }
  a:visited { text-decoration: none; padding: 1px 2px 1px 2px; }
  a:hover { text-decoration: none; padding: 1px 1px 1px 1px; border: 1px solid #000000; } 
  a:focus { text-decoration: none; padding: 1px 2px 1px 2px; border: none; }
  a.none { text-decoration: none; padding: 0; }
  a.none:visited { text-decoration: none; padding: 0; } 
  a.none:hover { text-decoration: none; border: none; padding: 0; } 
  a.none:focus { text-decoration: none; border: none; padding: 0; } 
  a.noborder { text-decoration: none; padding: 0; } 
  a.noborder:visited { text-decoration: none; padding: 0; } 
  a.noborder:hover { text-decoration: none; border: none; padding: 0; } 
  a.noborder:focus { text-decoration: none; border: none; padding: 0; }  
  pre.none { padding:5px; background-color:#ffffff }
  </style>
</head>

<body bgcolor=white>

<h2> CL-GLFW - A CL binding for GLFW</h2>

<blockquote>
<br>&nbsp;<br><h3><a name=abstract class=none>Abstract</a></h3>

Can currently be fetched from the git repository found here: http://repo.or.cz/w/cl-glfw.git

<p>Or via the asdf-install package:

<p><a class="download" href="http://wvr.me.uk/cl-glfw/cl-glfw_current.tar.gz"><b>Download ASDF package from http://wvr.me.uk/cl-glfw/cl-glfw_current.tar.gz</b></a>

<br>&nbsp;<br><h3><a class=none name="dict">The cl-glfw dictionary</a></h3>



<!-- Entry for +ACCELERATED+ -->

<p><br>[Constant]<br><a class=none name='+accelerated+'><b>+accelerated+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +ACCELERATED+ -->


<!-- Entry for +ACCUM-ALPHA-BITS+ -->

<p><br>[Constant]<br><a class=none name='+accum-alpha-bits+'><b>+accum-alpha-bits+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +ACCUM-ALPHA-BITS+ -->


<!-- Entry for +ACCUM-BLUE-BITS+ -->

<p><br>[Constant]<br><a class=none name='+accum-blue-bits+'><b>+accum-blue-bits+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +ACCUM-BLUE-BITS+ -->


<!-- Entry for +ACCUM-GREEN-BITS+ -->

<p><br>[Constant]<br><a class=none name='+accum-green-bits+'><b>+accum-green-bits+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +ACCUM-GREEN-BITS+ -->


<!-- Entry for +ACCUM-RED-BITS+ -->

<p><br>[Constant]<br><a class=none name='+accum-red-bits+'><b>+accum-red-bits+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +ACCUM-RED-BITS+ -->


<!-- Entry for +ACTIVE+ -->

<p><br>[Constant]<br><a class=none name='+active+'><b>+active+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +ACTIVE+ -->


<!-- Entry for +ALPHA-BITS+ -->

<p><br>[Constant]<br><a class=none name='+alpha-bits+'><b>+alpha-bits+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +ALPHA-BITS+ -->


<!-- Entry for +ALPHA-MAP-BIT+ -->

<p><br>[Constant]<br><a class=none name='+alpha-map-bit+'><b>+alpha-map-bit+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +ALPHA-MAP-BIT+ -->


<!-- Entry for +AUTO-POLL-EVENTS+ -->

<p><br>[Constant]<br><a class=none name='+auto-poll-events+'><b>+auto-poll-events+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +AUTO-POLL-EVENTS+ -->


<!-- Entry for +AUX-BUFFERS+ -->

<p><br>[Constant]<br><a class=none name='+aux-buffers+'><b>+aux-buffers+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +AUX-BUFFERS+ -->


<!-- Entry for +AXES+ -->

<p><br>[Constant]<br><a class=none name='+axes+'><b>+axes+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +AXES+ -->


<!-- Entry for +BLUE-BITS+ -->

<p><br>[Constant]<br><a class=none name='+blue-bits+'><b>+blue-bits+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +BLUE-BITS+ -->


<!-- Entry for +BUILD-MIPMAPS-BIT+ -->

<p><br>[Constant]<br><a class=none name='+build-mipmaps-bit+'><b>+build-mipmaps-bit+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +BUILD-MIPMAPS-BIT+ -->


<!-- Entry for +BUTTONS+ -->

<p><br>[Constant]<br><a class=none name='+buttons+'><b>+buttons+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +BUTTONS+ -->


<!-- Entry for +DEPTH-BITS+ -->

<p><br>[Constant]<br><a class=none name='+depth-bits+'><b>+depth-bits+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +DEPTH-BITS+ -->


<!-- Entry for +FALSE+ -->

<p><br>[Constant]<br><a class=none name='+false+'><b>+false+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +FALSE+ -->


<!-- Entry for +FSAA-SAMPLES+ -->

<p><br>[Constant]<br><a class=none name='+fsaa-samples+'><b>+fsaa-samples+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +FSAA-SAMPLES+ -->


<!-- Entry for +FULLSCREEN+ -->

<p><br>[Constant]<br><a class=none name='+fullscreen+'><b>+fullscreen+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +FULLSCREEN+ -->


<!-- Entry for +GREEN-BITS+ -->

<p><br>[Constant]<br><a class=none name='+green-bits+'><b>+green-bits+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +GREEN-BITS+ -->


<!-- Entry for +ICONIFIED+ -->

<p><br>[Constant]<br><a class=none name='+iconified+'><b>+iconified+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +ICONIFIED+ -->


<!-- Entry for +INFINITY+ -->

<p><br>[Constant]<br><a class=none name='+infinity+'><b>+infinity+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +INFINITY+ -->


<!-- Entry for +JOYSTICK-1+ -->

<p><br>[Constant]<br><a class=none name='+joystick-1+'><b>+joystick-1+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-1+ -->


<!-- Entry for +JOYSTICK-10+ -->

<p><br>[Constant]<br><a class=none name='+joystick-10+'><b>+joystick-10+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-10+ -->


<!-- Entry for +JOYSTICK-11+ -->

<p><br>[Constant]<br><a class=none name='+joystick-11+'><b>+joystick-11+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-11+ -->


<!-- Entry for +JOYSTICK-12+ -->

<p><br>[Constant]<br><a class=none name='+joystick-12+'><b>+joystick-12+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-12+ -->


<!-- Entry for +JOYSTICK-13+ -->

<p><br>[Constant]<br><a class=none name='+joystick-13+'><b>+joystick-13+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-13+ -->


<!-- Entry for +JOYSTICK-14+ -->

<p><br>[Constant]<br><a class=none name='+joystick-14+'><b>+joystick-14+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-14+ -->


<!-- Entry for +JOYSTICK-15+ -->

<p><br>[Constant]<br><a class=none name='+joystick-15+'><b>+joystick-15+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-15+ -->


<!-- Entry for +JOYSTICK-16+ -->

<p><br>[Constant]<br><a class=none name='+joystick-16+'><b>+joystick-16+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-16+ -->


<!-- Entry for +JOYSTICK-2+ -->

<p><br>[Constant]<br><a class=none name='+joystick-2+'><b>+joystick-2+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-2+ -->


<!-- Entry for +JOYSTICK-3+ -->

<p><br>[Constant]<br><a class=none name='+joystick-3+'><b>+joystick-3+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-3+ -->


<!-- Entry for +JOYSTICK-4+ -->

<p><br>[Constant]<br><a class=none name='+joystick-4+'><b>+joystick-4+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-4+ -->


<!-- Entry for +JOYSTICK-5+ -->

<p><br>[Constant]<br><a class=none name='+joystick-5+'><b>+joystick-5+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-5+ -->


<!-- Entry for +JOYSTICK-6+ -->

<p><br>[Constant]<br><a class=none name='+joystick-6+'><b>+joystick-6+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-6+ -->


<!-- Entry for +JOYSTICK-7+ -->

<p><br>[Constant]<br><a class=none name='+joystick-7+'><b>+joystick-7+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-7+ -->


<!-- Entry for +JOYSTICK-8+ -->

<p><br>[Constant]<br><a class=none name='+joystick-8+'><b>+joystick-8+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-8+ -->


<!-- Entry for +JOYSTICK-9+ -->

<p><br>[Constant]<br><a class=none name='+joystick-9+'><b>+joystick-9+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-9+ -->


<!-- Entry for +JOYSTICK-LAST+ -->

<p><br>[Constant]<br><a class=none name='+joystick-last+'><b>+joystick-last+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +JOYSTICK-LAST+ -->


<!-- Entry for +KEY-BACKSPACE+ -->

<p><br>[Constant]<br><a class=none name='+key-backspace+'><b>+key-backspace+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-BACKSPACE+ -->


<!-- Entry for +KEY-DEL+ -->

<p><br>[Constant]<br><a class=none name='+key-del+'><b>+key-del+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-DEL+ -->


<!-- Entry for +KEY-DOWN+ -->

<p><br>[Constant]<br><a class=none name='+key-down+'><b>+key-down+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-DOWN+ -->


<!-- Entry for +KEY-END+ -->

<p><br>[Constant]<br><a class=none name='+key-end+'><b>+key-end+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-END+ -->


<!-- Entry for +KEY-ENTER+ -->

<p><br>[Constant]<br><a class=none name='+key-enter+'><b>+key-enter+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-ENTER+ -->


<!-- Entry for +KEY-ESC+ -->

<p><br>[Constant]<br><a class=none name='+key-esc+'><b>+key-esc+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-ESC+ -->


<!-- Entry for +KEY-F1+ -->

<p><br>[Constant]<br><a class=none name='+key-f1+'><b>+key-f1+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F1+ -->


<!-- Entry for +KEY-F10+ -->

<p><br>[Constant]<br><a class=none name='+key-f10+'><b>+key-f10+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F10+ -->


<!-- Entry for +KEY-F11+ -->

<p><br>[Constant]<br><a class=none name='+key-f11+'><b>+key-f11+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F11+ -->


<!-- Entry for +KEY-F12+ -->

<p><br>[Constant]<br><a class=none name='+key-f12+'><b>+key-f12+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F12+ -->


<!-- Entry for +KEY-F13+ -->

<p><br>[Constant]<br><a class=none name='+key-f13+'><b>+key-f13+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F13+ -->


<!-- Entry for +KEY-F14+ -->

<p><br>[Constant]<br><a class=none name='+key-f14+'><b>+key-f14+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F14+ -->


<!-- Entry for +KEY-F15+ -->

<p><br>[Constant]<br><a class=none name='+key-f15+'><b>+key-f15+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F15+ -->


<!-- Entry for +KEY-F16+ -->

<p><br>[Constant]<br><a class=none name='+key-f16+'><b>+key-f16+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F16+ -->


<!-- Entry for +KEY-F17+ -->

<p><br>[Constant]<br><a class=none name='+key-f17+'><b>+key-f17+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F17+ -->


<!-- Entry for +KEY-F18+ -->

<p><br>[Constant]<br><a class=none name='+key-f18+'><b>+key-f18+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F18+ -->


<!-- Entry for +KEY-F19+ -->

<p><br>[Constant]<br><a class=none name='+key-f19+'><b>+key-f19+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F19+ -->


<!-- Entry for +KEY-F2+ -->

<p><br>[Constant]<br><a class=none name='+key-f2+'><b>+key-f2+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F2+ -->


<!-- Entry for +KEY-F20+ -->

<p><br>[Constant]<br><a class=none name='+key-f20+'><b>+key-f20+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F20+ -->


<!-- Entry for +KEY-F21+ -->

<p><br>[Constant]<br><a class=none name='+key-f21+'><b>+key-f21+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F21+ -->


<!-- Entry for +KEY-F22+ -->

<p><br>[Constant]<br><a class=none name='+key-f22+'><b>+key-f22+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F22+ -->


<!-- Entry for +KEY-F23+ -->

<p><br>[Constant]<br><a class=none name='+key-f23+'><b>+key-f23+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F23+ -->


<!-- Entry for +KEY-F24+ -->

<p><br>[Constant]<br><a class=none name='+key-f24+'><b>+key-f24+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F24+ -->


<!-- Entry for +KEY-F25+ -->

<p><br>[Constant]<br><a class=none name='+key-f25+'><b>+key-f25+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F25+ -->


<!-- Entry for +KEY-F3+ -->

<p><br>[Constant]<br><a class=none name='+key-f3+'><b>+key-f3+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F3+ -->


<!-- Entry for +KEY-F4+ -->

<p><br>[Constant]<br><a class=none name='+key-f4+'><b>+key-f4+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F4+ -->


<!-- Entry for +KEY-F5+ -->

<p><br>[Constant]<br><a class=none name='+key-f5+'><b>+key-f5+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F5+ -->


<!-- Entry for +KEY-F6+ -->

<p><br>[Constant]<br><a class=none name='+key-f6+'><b>+key-f6+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F6+ -->


<!-- Entry for +KEY-F7+ -->

<p><br>[Constant]<br><a class=none name='+key-f7+'><b>+key-f7+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F7+ -->


<!-- Entry for +KEY-F8+ -->

<p><br>[Constant]<br><a class=none name='+key-f8+'><b>+key-f8+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F8+ -->


<!-- Entry for +KEY-F9+ -->

<p><br>[Constant]<br><a class=none name='+key-f9+'><b>+key-f9+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-F9+ -->


<!-- Entry for +KEY-HOME+ -->

<p><br>[Constant]<br><a class=none name='+key-home+'><b>+key-home+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-HOME+ -->


<!-- Entry for +KEY-INSERT+ -->

<p><br>[Constant]<br><a class=none name='+key-insert+'><b>+key-insert+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-INSERT+ -->


<!-- Entry for +KEY-KP-0+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-0+'><b>+key-kp-0+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-0+ -->


<!-- Entry for +KEY-KP-1+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-1+'><b>+key-kp-1+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-1+ -->


<!-- Entry for +KEY-KP-2+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-2+'><b>+key-kp-2+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-2+ -->


<!-- Entry for +KEY-KP-3+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-3+'><b>+key-kp-3+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-3+ -->


<!-- Entry for +KEY-KP-4+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-4+'><b>+key-kp-4+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-4+ -->


<!-- Entry for +KEY-KP-5+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-5+'><b>+key-kp-5+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-5+ -->


<!-- Entry for +KEY-KP-6+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-6+'><b>+key-kp-6+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-6+ -->


<!-- Entry for +KEY-KP-7+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-7+'><b>+key-kp-7+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-7+ -->


<!-- Entry for +KEY-KP-8+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-8+'><b>+key-kp-8+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-8+ -->


<!-- Entry for +KEY-KP-9+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-9+'><b>+key-kp-9+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-9+ -->


<!-- Entry for +KEY-KP-ADD+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-add+'><b>+key-kp-add+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-ADD+ -->


<!-- Entry for +KEY-KP-DECIMAL+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-decimal+'><b>+key-kp-decimal+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-DECIMAL+ -->


<!-- Entry for +KEY-KP-DIVIDE+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-divide+'><b>+key-kp-divide+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-DIVIDE+ -->


<!-- Entry for +KEY-KP-ENTER+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-enter+'><b>+key-kp-enter+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-ENTER+ -->


<!-- Entry for +KEY-KP-EQUAL+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-equal+'><b>+key-kp-equal+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-EQUAL+ -->


<!-- Entry for +KEY-KP-MULTIPLY+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-multiply+'><b>+key-kp-multiply+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-MULTIPLY+ -->


<!-- Entry for +KEY-KP-SUBTRACT+ -->

<p><br>[Constant]<br><a class=none name='+key-kp-subtract+'><b>+key-kp-subtract+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-KP-SUBTRACT+ -->


<!-- Entry for +KEY-LALT+ -->

<p><br>[Constant]<br><a class=none name='+key-lalt+'><b>+key-lalt+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-LALT+ -->


<!-- Entry for +KEY-LAST+ -->

<p><br>[Constant]<br><a class=none name='+key-last+'><b>+key-last+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-LAST+ -->


<!-- Entry for +KEY-LCTRL+ -->

<p><br>[Constant]<br><a class=none name='+key-lctrl+'><b>+key-lctrl+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-LCTRL+ -->


<!-- Entry for +KEY-LEFT+ -->

<p><br>[Constant]<br><a class=none name='+key-left+'><b>+key-left+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-LEFT+ -->


<!-- Entry for +KEY-LSHIFT+ -->

<p><br>[Constant]<br><a class=none name='+key-lshift+'><b>+key-lshift+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-LSHIFT+ -->


<!-- Entry for +KEY-PAGEDOWN+ -->

<p><br>[Constant]<br><a class=none name='+key-pagedown+'><b>+key-pagedown+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-PAGEDOWN+ -->


<!-- Entry for +KEY-PAGEUP+ -->

<p><br>[Constant]<br><a class=none name='+key-pageup+'><b>+key-pageup+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-PAGEUP+ -->


<!-- Entry for +KEY-RALT+ -->

<p><br>[Constant]<br><a class=none name='+key-ralt+'><b>+key-ralt+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-RALT+ -->


<!-- Entry for +KEY-RCTRL+ -->

<p><br>[Constant]<br><a class=none name='+key-rctrl+'><b>+key-rctrl+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-RCTRL+ -->


<!-- Entry for +KEY-REPEAT+ -->

<p><br>[Constant]<br><a class=none name='+key-repeat+'><b>+key-repeat+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-REPEAT+ -->


<!-- Entry for +KEY-RIGHT+ -->

<p><br>[Constant]<br><a class=none name='+key-right+'><b>+key-right+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-RIGHT+ -->


<!-- Entry for +KEY-RSHIFT+ -->

<p><br>[Constant]<br><a class=none name='+key-rshift+'><b>+key-rshift+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-RSHIFT+ -->


<!-- Entry for +KEY-SPACE+ -->

<p><br>[Constant]<br><a class=none name='+key-space+'><b>+key-space+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-SPACE+ -->


<!-- Entry for +KEY-SPECIAL+ -->

<p><br>[Constant]<br><a class=none name='+key-special+'><b>+key-special+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-SPECIAL+ -->


<!-- Entry for +KEY-TAB+ -->

<p><br>[Constant]<br><a class=none name='+key-tab+'><b>+key-tab+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-TAB+ -->


<!-- Entry for +KEY-UNKNOWN+ -->

<p><br>[Constant]<br><a class=none name='+key-unknown+'><b>+key-unknown+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-UNKNOWN+ -->


<!-- Entry for +KEY-UP+ -->

<p><br>[Constant]<br><a class=none name='+key-up+'><b>+key-up+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +KEY-UP+ -->


<!-- Entry for +MOUSE-BUTTON-1+ -->

<p><br>[Constant]<br><a class=none name='+mouse-button-1+'><b>+mouse-button-1+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-BUTTON-1+ -->


<!-- Entry for +MOUSE-BUTTON-2+ -->

<p><br>[Constant]<br><a class=none name='+mouse-button-2+'><b>+mouse-button-2+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-BUTTON-2+ -->


<!-- Entry for +MOUSE-BUTTON-3+ -->

<p><br>[Constant]<br><a class=none name='+mouse-button-3+'><b>+mouse-button-3+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-BUTTON-3+ -->


<!-- Entry for +MOUSE-BUTTON-4+ -->

<p><br>[Constant]<br><a class=none name='+mouse-button-4+'><b>+mouse-button-4+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-BUTTON-4+ -->


<!-- Entry for +MOUSE-BUTTON-5+ -->

<p><br>[Constant]<br><a class=none name='+mouse-button-5+'><b>+mouse-button-5+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-BUTTON-5+ -->


<!-- Entry for +MOUSE-BUTTON-6+ -->

<p><br>[Constant]<br><a class=none name='+mouse-button-6+'><b>+mouse-button-6+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-BUTTON-6+ -->


<!-- Entry for +MOUSE-BUTTON-7+ -->

<p><br>[Constant]<br><a class=none name='+mouse-button-7+'><b>+mouse-button-7+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-BUTTON-7+ -->


<!-- Entry for +MOUSE-BUTTON-8+ -->

<p><br>[Constant]<br><a class=none name='+mouse-button-8+'><b>+mouse-button-8+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-BUTTON-8+ -->


<!-- Entry for +MOUSE-BUTTON-LAST+ -->

<p><br>[Constant]<br><a class=none name='+mouse-button-last+'><b>+mouse-button-last+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-BUTTON-LAST+ -->


<!-- Entry for +MOUSE-BUTTON-LEFT+ -->

<p><br>[Constant]<br><a class=none name='+mouse-button-left+'><b>+mouse-button-left+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-BUTTON-LEFT+ -->


<!-- Entry for +MOUSE-BUTTON-MIDDLE+ -->

<p><br>[Constant]<br><a class=none name='+mouse-button-middle+'><b>+mouse-button-middle+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-BUTTON-MIDDLE+ -->


<!-- Entry for +MOUSE-BUTTON-RIGHT+ -->

<p><br>[Constant]<br><a class=none name='+mouse-button-right+'><b>+mouse-button-right+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-BUTTON-RIGHT+ -->


<!-- Entry for +MOUSE-CURSOR+ -->

<p><br>[Constant]<br><a class=none name='+mouse-cursor+'><b>+mouse-cursor+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +MOUSE-CURSOR+ -->


<!-- Entry for +NO-RESCALE-BIT+ -->

<p><br>[Constant]<br><a class=none name='+no-rescale-bit+'><b>+no-rescale-bit+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +NO-RESCALE-BIT+ -->


<!-- Entry for +NOWAIT+ -->

<p><br>[Constant]<br><a class=none name='+nowait+'><b>+nowait+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +NOWAIT+ -->


<!-- Entry for +OPENED+ -->

<p><br>[Constant]<br><a class=none name='+opened+'><b>+opened+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +OPENED+ -->


<!-- Entry for +ORIGIN-UL-BIT+ -->

<p><br>[Constant]<br><a class=none name='+origin-ul-bit+'><b>+origin-ul-bit+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +ORIGIN-UL-BIT+ -->


<!-- Entry for +PRESENT+ -->

<p><br>[Constant]<br><a class=none name='+present+'><b>+present+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +PRESENT+ -->


<!-- Entry for +PRESS+ -->

<p><br>[Constant]<br><a class=none name='+press+'><b>+press+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +PRESS+ -->


<!-- Entry for +RED-BITS+ -->

<p><br>[Constant]<br><a class=none name='+red-bits+'><b>+red-bits+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +RED-BITS+ -->


<!-- Entry for +REFRESH-RATE+ -->

<p><br>[Constant]<br><a class=none name='+refresh-rate+'><b>+refresh-rate+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +REFRESH-RATE+ -->


<!-- Entry for +RELEASE+ -->

<p><br>[Constant]<br><a class=none name='+release+'><b>+release+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +RELEASE+ -->


<!-- Entry for +STENCIL-BITS+ -->

<p><br>[Constant]<br><a class=none name='+stencil-bits+'><b>+stencil-bits+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +STENCIL-BITS+ -->


<!-- Entry for +STEREO+ -->

<p><br>[Constant]<br><a class=none name='+stereo+'><b>+stereo+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +STEREO+ -->


<!-- Entry for +STICKY-KEYS+ -->

<p><br>[Constant]<br><a class=none name='+sticky-keys+'><b>+sticky-keys+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +STICKY-KEYS+ -->


<!-- Entry for +STICKY-MOUSE-BUTTONS+ -->

<p><br>[Constant]<br><a class=none name='+sticky-mouse-buttons+'><b>+sticky-mouse-buttons+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +STICKY-MOUSE-BUTTONS+ -->


<!-- Entry for +SYSTEM-KEYS+ -->

<p><br>[Constant]<br><a class=none name='+system-keys+'><b>+system-keys+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +SYSTEM-KEYS+ -->


<!-- Entry for +TRUE+ -->

<p><br>[Constant]<br><a class=none name='+true+'><b>+true+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +TRUE+ -->


<!-- Entry for +WAIT+ -->

<p><br>[Constant]<br><a class=none name='+wait+'><b>+wait+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +WAIT+ -->


<!-- Entry for +WINDOW+ -->

<p><br>[Constant]<br><a class=none name='+window+'><b>+window+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +WINDOW+ -->


<!-- Entry for +WINDOW-NO-RESIZE+ -->

<p><br>[Constant]<br><a class=none name='+window-no-resize+'><b>+window-no-resize+</b></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for +WINDOW-NO-RESIZE+ -->


<!-- Entry for BROADCAST-COND -->

<p><br>[Function]<br><a class=none name='broadcast-cond'><b>broadcast-cond</b> <i>cond</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
cond
      A condition variable object handle.
Description
The function restarts all the threads that are waiting on the condition variable cond. If no threads are
waiting on cond, nothing happens.
Notes
When several threads are waiting for the condition variable, the order in which threads are started
depends on operating system scheduling rules, and may vary from system to system and from time to
time.


</pre></blockquote>

<!-- End of entry for BROADCAST-COND -->


<!-- Entry for CLOSE-WINDOW -->

<p><br>[Function]<br><a class=none name='close-window'><b>close-window</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

The function closes an opened window and destroys the associated OpenGL™ context.

</pre></blockquote>

<!-- End of entry for CLOSE-WINDOW -->


<!-- Entry for CREATE-COND -->

<p><br>[Function]<br><a class=none name='create-cond'><b>create-cond</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Return values
The function returns a condition variable handle, or NULL if the condition variable could not be
created.
Description
The function creates a condition variable object, which can be used to synchronize threads.


</pre></blockquote>

<!-- End of entry for CREATE-COND -->


<!-- Entry for CREATE-MUTEX -->

<p><br>[Function]<br><a class=none name='create-mutex'><b>create-mutex</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Return values
The function returns a mutex handle, or NULL if the mutex could not be created.
Description
The function creates a mutex object, which can be used to control access to data that is shared between
threads.


</pre></blockquote>

<!-- End of entry for CREATE-MUTEX -->


<!-- Entry for CREATE-THREAD -->

<p><br>[Function]<br><a class=none name='create-thread'><b>create-thread</b> <i>fun arg</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
fun
      A pointer to a function that acts as the entry point for the new thread. The function should have
      the following C language prototype:
      void GLFWCALL functionname( void *arg );
      Where functionname is the name of the thread function, and arg is the user supplied argument
      (see below).
arg
      An arbitrary argument for the thread. arg will be passed as the argument to the thread function
      pointed to by fun. For instance, arg can point to data that is to be processed by the thread.
Return values
The function returns a thread identification number if the thread was created successfully. This number
is always positive. If the function fails, a negative number is returned.
Description
The function creates a new thread, which executes within the same address space as the calling process.
The thread entry point is specified with the fun argument.
Once the thread function fun returns, the thread dies.
Notes
Even if the function returns a positive thread ID, indicating that the thread was created successfully, the
thread may be unable to execute, for instance if the thread start address is not a valid thread entry point.


</pre></blockquote>

<!-- End of entry for CREATE-THREAD -->


<!-- Entry for DEFCFUN+DOC -->

<p><br>[Macro]<br><a class=none name='defcfun+doc'><b>defcfun+doc</b> <i>(c-name lisp-name) return-type (declaration* statement*) docstring</i> =&gt; <i>result</i></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for DEFCFUN+DOC -->


<!-- Entry for DEFCFUN+OUT+DOC -->

<p><br>[Macro]<br><a class=none name='defcfun+out+doc'><b>defcfun+out+doc</b> <i>(c-name lisp-name) return-type (declaration* statement*) docstring</i> =&gt; <i>result</i></a>
<blockquote><br><pre>



</pre></blockquote>

<!-- End of entry for DEFCFUN+OUT+DOC -->


<!-- Entry for DESTROY-COND -->

<p><br>[Function]<br><a class=none name='destroy-cond'><b>destroy-cond</b> <i>cond</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
cond
      A condition variable object handle.
Description
The function destroys a condition variable object. After a condition variable object has been destroyed,
it may no longer be used by any thread.


</pre></blockquote>

<!-- End of entry for DESTROY-COND -->


<!-- Entry for DESTROY-MUTEX -->

<p><br>[Function]<br><a class=none name='destroy-mutex'><b>destroy-mutex</b> <i>mutex</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
mutex
      A mutex object handle.
Description
The function destroys a mutex object. After a mutex object has been destroyed, it may no longer be
used by any thread.


</pre></blockquote>

<!-- End of entry for DESTROY-MUTEX -->


<!-- Entry for DESTROY-THREAD -->

<p><br>[Function]<br><a class=none name='destroy-thread'><b>destroy-thread</b> <i>id</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
ID
      A thread identification handle, which is returned by glfw::CreateThread or glfw::GetThreadID.
Description
The function kills a running thread and removes it from the thread list.
Notes
This function is a very dangerous operation, which may interrupt a thread in the middle of an important
operation, and its use is discouraged. You should always try to end a thread in a graceful way using
thread communication, and use glfw::WaitThread in order to wait for the thread to die.


</pre></blockquote>

<!-- End of entry for DESTROY-THREAD -->


<!-- Entry for DISABLE -->

<p><br>[Function]<br><a class=none name='disable'><b>disable</b> <i>token</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
token
       A value specifying a feature to enable or disable. Valid tokens are listed in table 3.8.
Return values
none
Description
glfw::Enable is used to enable a certain feature, while glfw::Disable is used to disable it. Below follows a
description of each feature.
+AUTO_POLL_EVENTS+
When +AUTO_POLL_EVENTS+ is enabled, glfw::PollEvents is automatically called each time
that glfw::SwapBuffers is called.
When +AUTO_POLL_EVENTS+ is disabled, calling glfw::SwapBuffers will not result in a call to
glfw::PollEvents. This can be useful if glfw::SwapBuffers needs to be called from within a callback
function, since calling glfw::PollEvents from a callback function is not allowed.
+KEY_REPEAT+
When +KEY_REPEAT+ is enabled, the key and character callback functions are called repeatedly
when a key is held down long enough (according to the system key repeat configuration).
When +KEY_REPEAT+ is disabled, the key and character callback functions are only called once
when a key is pressed (and once when it is released).
+MOUSE_CURSOR+
When +MOUSE_CURSOR+ is enabled, the mouse cursor is visible, and mouse coordinates are
relative to the upper left corner of the client area of the GLFW window. The coordinates are limited to
the client area of the window.
When +MOUSE_CURSOR+ is disabled, the mouse cursor is invisible, and mouse coordinates are
not limited to the drawing area of the window. It is as if the mouse coordinates are recieved directly
from the mouse, without being restricted or manipulated by the windowing system.
+STICKY_KEYS+
When +STICKY_KEYS+ is enabled, keys which are pressed will not be released until they are
physically released and checked with glfw::GetKey. This behavior makes it possible to catch keys that
were pressed and then released again between two calls to glfw::PollEvents, glfw::WaitEvents or
glfw::SwapBuffers, which would otherwise have been reported as released. Care should be taken when
using this mode, since keys that are not checked with glfw::GetKey will never be released. Note also that
enabling +STICKY_KEYS+ does not affect the behavior of the keyboard callback functionality.
When +STICKY_KEYS+ is disabled, the status of a key that is reported by glfwGetKey is always
the physical state of the key. Disabling +STICKY_KEYS+ also clears the sticky information for
all keys.
+STICKY_MOUSE_BUTTONS+
When +STICKY_MOUSE_BUTTONS+ is enabled, mouse buttons that are pressed will not be
released until they are physically released and checked with glfw::GetMouseButton. This behavior
makes it possible to catch mouse buttons which were pressed and then released again between two calls
to glfw::PollEvents, glfw::WaitEvents or glfw::SwapBuffers, which would otherwise have been reported
as released. Care should be taken when using this mode, since mouse buttons that are not checked with
glfw::GetMouseButton will never be released. Note also that enabling
+STICKY_MOUSE_BUTTONS+ does not affect the behavior of the mouse button callback
functionality.
When +STICKY_MOUSE_BUTTONS+ is disabled, the status of a mouse button that is reported
by glfwGetMouseButton is always the physical state of the mouse button. Disabling
+STICKY_MOUSE_BUTTONS+ also clears the sticky information for all mouse buttons.
+SYSTEM_KEYS+
When +SYSTEM_KEYS+ is enabled, pressing standard system key combinations, such as
ALT+TAB under Windows, will give the normal behavior. Note that when ALT+TAB is issued under
Windows in this mode so that the GLFW application is deselected when GLFW is operating in
fullscreen mode, the GLFW application window will be minimized and the video mode will be set to
the original desktop mode. When the GLFW application is re-selected, the video mode will be set to
the GLFW video mode again.
When +SYSTEM_KEYS+ is disabled, pressing standard system key combinations will have no
effect, since those key combinations are blocked by GLFW. This mode can be useful in situations when
the GLFW program must not be interrupted (normally for games in fullscreen mode).


</pre></blockquote>

<!-- End of entry for DISABLE -->


<!-- Entry for DO-WINDOW -->

<p><br>[Macro]<br><a class=none name='do-window'><b>do-window</b> <i>(<tt>&amp;optional</tt> title width height redbits greenbits bluebits alphabits depthbits stencilbits mode) (declaration* statement*) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

High-level convenience macro for initializing glfw, opening a window (given the optional window parameters),
setting the title given,
running setup-forms and then running forms in a loop, with calls to swap-buffers after each loop iteration.
The loop is in a block named do-window [so can be exited by a call to (return-from glfw:do-window)].
If the window is closed, the loop is also exited.

</pre></blockquote>

<!-- End of entry for DO-WINDOW -->


<!-- Entry for ENABLE -->

<p><br>[Function]<br><a class=none name='enable'><b>enable</b> <i>token</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
token
       A value specifying a feature to enable or disable. Valid tokens are listed in table 3.8.
Return values
none
Description
glfw::Enable is used to enable a certain feature, while glfw::Disable is used to disable it. Below follows a
description of each feature.
+AUTO_POLL_EVENTS+
When +AUTO_POLL_EVENTS+ is enabled, glfw::PollEvents is automatically called each time
that glfw::SwapBuffers is called.
When +AUTO_POLL_EVENTS+ is disabled, calling glfw::SwapBuffers will not result in a call to
glfw::PollEvents. This can be useful if glfw::SwapBuffers needs to be called from within a callback
function, since calling glfw::PollEvents from a callback function is not allowed.
+KEY_REPEAT+
When +KEY_REPEAT+ is enabled, the key and character callback functions are called repeatedly
when a key is held down long enough (according to the system key repeat configuration).
When +KEY_REPEAT+ is disabled, the key and character callback functions are only called once
when a key is pressed (and once when it is released).
+MOUSE_CURSOR+
When +MOUSE_CURSOR+ is enabled, the mouse cursor is visible, and mouse coordinates are
relative to the upper left corner of the client area of the GLFW window. The coordinates are limited to
the client area of the window.
When +MOUSE_CURSOR+ is disabled, the mouse cursor is invisible, and mouse coordinates are
not limited to the drawing area of the window. It is as if the mouse coordinates are recieved directly
from the mouse, without being restricted or manipulated by the windowing system.
+STICKY_KEYS+
When +STICKY_KEYS+ is enabled, keys which are pressed will not be released until they are
physically released and checked with glfw::GetKey. This behavior makes it possible to catch keys that
were pressed and then released again between two calls to glfw::PollEvents, glfw::WaitEvents or
glfw::SwapBuffers, which would otherwise have been reported as released. Care should be taken when
using this mode, since keys that are not checked with glfw::GetKey will never be released. Note also that
enabling +STICKY_KEYS+ does not affect the behavior of the keyboard callback functionality.
When +STICKY_KEYS+ is disabled, the status of a key that is reported by glfw::GetKey is always
the physical state of the key. Disabling +STICKY_KEYS+ also clears the sticky information for
all keys.
+STICKY_MOUSE_BUTTONS+
When +STICKY_MOUSE_BUTTONS+ is enabled, mouse buttons that are pressed will not be
released until they are physically released and checked with glfw::GetMouseButton. This behavior
makes it possible to catch mouse buttons which were pressed and then released again between two calls
to glfw::PollEvents, glfw::WaitEvents or glfw::SwapBuffers, which would otherwise have been reported
as released. Care should be taken when using this mode, since mouse buttons that are not checked with
glfw::GetMouseButton will never be released. Note also that enabling
+STICKY_MOUSE_BUTTONS+ does not affect the behavior of the mouse button callback
functionality.
When +STICKY_MOUSE_BUTTONS+ is disabled, the status of a mouse button that is reported
by glfw::GetMouseButton is always the physical state of the mouse button. Disabling
+STICKY_MOUSE_BUTTONS+ also clears the sticky information for all mouse buttons.
+SYSTEM_KEYS+
When +SYSTEM_KEYS+ is enabled, pressing standard system key combinations, such as
ALT+TAB under Windows, will give the normal behavior. Note that when ALT+TAB is issued under
Windows in this mode so that the GLFW application is deselected when GLFW is operating in
fullscreen mode, the GLFW application window will be minimized and the video mode will be set to
the original desktop mode. When the GLFW application is re-selected, the video mode will be set to
the GLFW video mode again.
When +SYSTEM_KEYS+ is disabled, pressing standard system key combinations will have no
effect, since those key combinations are blocked by GLFW. This mode can be useful in situations when
the GLFW program must not be interrupted (normally for games in fullscreen mode).


</pre></blockquote>

<!-- End of entry for ENABLE -->


<!-- Entry for EXTENSION-SUPPORTED -->

<p><br>[Function]<br><a class=none name='extension-supported'><b>extension-supported</b> <i>extension</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
extension
      A null terminated ISO 8859-1 string containing the name of an OpenGL™ extension.
Return values
The function returns t if the extension is supported. Otherwise it returns nil.
Description
The function does a string search in the list of supported OpenGL™ extensions to find if the specified
extension is listed.
Notes
An OpenGL™ context must be created before this function can be called (i.e. an OpenGL™ window
must have been opened with glfw::OpenWindow).
In addition to checking for OpenGL™ extensions, GLFW also checks for extensions in the operating
system “glue API”, such as WGL extensions under Windows and glX extensions under the X Window
System.


</pre></blockquote>

<!-- End of entry for EXTENSION-SUPPORTED -->


<!-- Entry for FREE-IMAGE -->

<p><br>[Function]<br><a class=none name='free-image'><b>free-image</b> <i>img</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
img
     Pointer to a GLFWimage struct.
Description
The function frees any memory occupied by a loaded image, and clears all the fields of the GLFWimage
struct. Any image that has been loaded by the glfw::ReadImage function should be deallocated using
this function, once the image is not needed anymore. 

</pre></blockquote>

<!-- End of entry for FREE-IMAGE -->


<!-- Entry for GET-DESKTOP-MODE -->

<p><br>[Function]<br><a class=none name='get-desktop-mode'><b>get-desktop-mode</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
mode
       Pointer to a GLFWvidmode structure, which will be filled out by the function.
Return values
The GLFWvidmode structure pointed to by mode is filled out with the desktop video mode.
Description
The function returns the desktop video mode in a GLFWvidmode structure. See glfwGetVideoModes
for a definition of the GLFWvidmode structure.
Notes
The color depth of the desktop display is always reported as the number of bits for each individual color
component (red, green and blue), even if the desktop is not using an RGB or RGBA color format. For
instance, an indexed 256 color display may report RedBits = 3, GreenBits = 3 and BlueBits = 2, which
adds up to 8 bits in total.
The desktop video mode is the video mode used by the desktop, not the current video mode (which may
differ from the desktop video mode if the GLFW window is a fullscreen window).


</pre></blockquote>

<!-- End of entry for GET-DESKTOP-MODE -->


<!-- Entry for GET-GL-VERSION -->

<p><br>[Function]<br><a class=none name='get-gl-version'><b>get-gl-version</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Return values
The function returns the major and minor version numbers and the revision for the currently used
OpenGL™ implementation as a list (major minor rev).

Description
The function returns the OpenGL™ implementation version. This is a convenient function that parses
the version number information from the string returned by calling
glGetString( GL_VERSION ). The OpenGL™ version information can be used to determine
what functionality is supported by the used OpenGL™ implementation.

Notes
An OpenGL™ context must be created before this function can be called (i.e. an OpenGL™ window
must have been opened with glfwOpenWindow). 

</pre></blockquote>

<!-- End of entry for GET-GL-VERSION -->


<!-- Entry for GET-JOYSTICK-BUTTONS -->

<p><br>[Function]<br><a class=none name='get-joystick-buttons'><b>get-joystick-buttons</b> <i>joy numbuttons</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
joy
       A joystick identifier, which should be +JOYSTICK_n+ where n is in the range 1 to 16.
numbuttons
       Specifies how many buttons should be returned.
Return values
       A list that will hold the button states for all requested buttons.
The function returns the number of actually returned buttons. This is the minimum of numbuttons and
the number of buttons supported by the joystick. If the joystick is not supported or connected, the
function will return 0 (zero).

Description
The function queries the current state of one or more buttons of a joystick. The button states are
returned in an array, where the first element represents the first button of the joystick. Each state can be
either +PRESS+ or +RELEASE+
If numbuttons exceeds the number of buttons supported by the joystick, or if the joystick is not
available, the unused elements in the buttons array will be set to +RELEASE+

Notes
The joystick state is updated every time the function is called, so there is no need to call glfw::PollEvents
or glfw::WaitEvents for joystick state to be updated.
Use glfw::GetJoystickParam to retrieve joystick capabilities, such as joystick availability and number of
supported buttons.
No window has to be opened for joystick input to be valid.


</pre></blockquote>

<!-- End of entry for GET-JOYSTICK-BUTTONS -->


<!-- Entry for GET-JOYSTICK-PARAM -->

<p><br>[Function]<br><a class=none name='get-joystick-param'><b>get-joystick-param</b> <i>joy param</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
joy
      A joystick identifier, which should be +JOYSTICK_n+ where n is in the range 1 to 16.
param
      A token selecting which parameter the function should return (see table 3.5).
Return values
The function returns different parameters depending on the value of param. Table 3.5 lists valid param
values, and their corresponding return values.
Description
The function is used for acquiring various properties of a joystick.
Notes
The joystick information is updated every time the function is called.
No window has to be opened for joystick information to be valid.


</pre></blockquote>

<!-- End of entry for GET-JOYSTICK-PARAM -->


<!-- Entry for GET-JOYSTICK-POS -->

<p><br>[Function]<br><a class=none name='get-joystick-pos'><b>get-joystick-pos</b> <i>joy numaxes</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
joy
       A joystick identifier, which should be +JOYSTICK_n+ where n is in the range 1 to 16.
numaxes
       Specifies how many axes should be returned.
Return values
       An list that will hold the positional values for all requested axes.
If the joystick is not supported or connected, the function will
return nil.

Description
The function queries the current position of one or more axes of a joystick. The positional values are
returned in an array, where the first element represents the first axis of the joystick (normally the X
axis). Each position is in the range -1.0 to 1.0. Where applicable, the positive direction of an axis is
right, forward or up, and the negative direction is left, back or down.
If numaxes exceeds the number of axes supported by the joystick, or if the joystick is not available, the
unused elements in the pos array will be set to 0.0 (zero).

Notes
The joystick state is updated every time the function is called, so there is no need to call glfw::PollEvents
or glfw::WaitEvents for joystick state to be updated.
Use glfw::GetJoystickParam to retrieve joystick capabilities, such as joystick availability and number of
supported axes.
No window has to be opened for joystick input to be valid.


</pre></blockquote>

<!-- End of entry for GET-JOYSTICK-POS -->


<!-- Entry for GET-KEY -->

<p><br>[Function]<br><a class=none name='get-key'><b>get-key</b> <i>key</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
key
      A keyboard key identifier, which can be either an uppercase printable ISO 8859-1 (Latin 1)
      character (e.g. &#039;A&#039;, &#039;3&#039; or &#039;.&#039;), or a special key identifier. Table 3.3 lists valid special key
      identifiers.
Return values
The function returns +PRESS+ if the key is held down, or +RELEASE+ if the key is not
held down.

Description
The function queries the current state of a specific keyboard key. The physical location of each key
depends on the system keyboard layout setting.

Notes
The constant +KEY_SPACE+ is equal to 32, which is the ISO 8859-1 code for space.
Not all key codes are supported on all systems. Also, while some keys are available on some keyboard
layouts, they may not be available on other keyboard layouts.
For systems that do not distinguish between left and right versions of modifier keys (shift, alt and
control), the left version is used (e.g. +KEY_LSHIFT+)
A window must be opened for the function to have any effect, and glfw::PollEvents, glfw::WaitEvents or
glfw::SwapBuffers must be called before any keyboard events are recorded and reported by
glfw::GetKey.


</pre></blockquote>

<!-- End of entry for GET-KEY -->


<!-- Entry for GET-MOUSE-BUTTON -->

<p><br>[Function]<br><a class=none name='get-mouse-button'><b>get-mouse-button</b> <i>button</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
button
      A mouse button identifier, which can be one of the mouse button identifiers listed in table 3.4.
Return values
The function returns +PRESS+ if the mouse button is held down, or +RELEASE+ if the
mouse button is not held down.
Description
The function queries the current state of a specific mouse button.
Notes
A window must be opened for the function to have any effect, and glfw::PollEvents, glfw::WaitEvents or
glfw::SwapBuffers must be called before any mouse button events are recorded and reported by
glfw::GetMouseButton.
+MOUSE_BUTTON_LEFT+ is equal to +MOUSE_BUTTON_1+
+MOUSE_BUTTON_RIGHT+ is equal to +MOUSE_BUTTON_2+
+MOUSE_BUTTON_MIDDLE+ is equal to +MOUSE_BUTTON_3+


</pre></blockquote>

<!-- End of entry for GET-MOUSE-BUTTON -->


<!-- Entry for GET-MOUSE-POS -->

<p><br>[Function]<br><a class=none name='get-mouse-pos'><b>get-mouse-pos</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Return values
The function returns the current mouse position in xpos and ypos.

Description
The function returns the current mouse position. If the cursor is not hidden, the mouse position is the
cursor position, relative to the upper left corner of the window and limited to the client area of the
window. If the cursor is hidden, the mouse position is a virtual absolute position, not limited to any
boundaries except to those implied by the maximum number that can be represented by a signed integer
(normally -2147483648 to +2147483647).

Notes
A window must be opened for the function to have any effect, and glfw::PollEvents, glfw::WaitEvents or
glfw::SwapBuffers must be called before any mouse movements are recorded and reported by
glfw::GetMousePos.


</pre></blockquote>

<!-- End of entry for GET-MOUSE-POS -->


<!-- Entry for GET-MOUSE-WHEEL -->

<p><br>[Function]<br><a class=none name='get-mouse-wheel'><b>get-mouse-wheel</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Return values
The function returns the current mouse wheel position.
Description
The function returns the current mouse wheel position. The mouse wheel can be thought of as a third
mouse axis, which is available as a separate wheel or up/down stick on some mice.
Notes
A window must be opened for the function to have any effect, and glfw::PollEvents, glfw::WaitEvents or
glfw::SwapBuffers must be called before any mouse wheel movements are recorded and reported by
glfw::GetMouseWheel.


</pre></blockquote>

<!-- End of entry for GET-MOUSE-WHEEL -->


<!-- Entry for GET-NUMBER-OF-PROCESSORS -->

<p><br>[Function]<br><a class=none name='get-number-of-processors'><b>get-number-of-processors</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Return values
The function returns the number of active processors in the system.
Description
The function determines the number of active processors in the system.
Notes
Systems with several logical processors per physical processor, also known as SMT (Symmetric Multi
Threading) processors, will report the number of logical processors.


</pre></blockquote>

<!-- End of entry for GET-NUMBER-OF-PROCESSORS -->


<!-- Entry for GET-PROC-ADDRESS -->

<p><br>[Function]<br><a class=none name='get-proc-address'><b>get-proc-address</b> <i>procname</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
procname
       A null terminated ISO 8859-1 string containing the name of an OpenGL™ extension function.
Return values
The function returns the pointer to the specified OpenGL™ function if it is supported, otherwise
NULL is returned.
Description
The function acquires the pointer to an OpenGL™ extension function. Some (but not all) OpenGL™
extensions define new API functions, which are usually not available through normal linking. It is
therefore necessary to get access to those API functions at runtime.
Notes
An OpenGL™ context must be created before this function can be called (i.e. an OpenGL™ window
must have been opened with glfw::OpenWindow).
Some systems do not support dynamic function pointer retrieval, in which case glfw::GetProcAddress
will always return NULL.


</pre></blockquote>

<!-- End of entry for GET-PROC-ADDRESS -->


<!-- Entry for GET-THREAD-ID -->

<p><br>[Function]<br><a class=none name='get-thread-id'><b>get-thread-id</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Return values
The function returns a thread identification handle for the calling thread.
Description
The function determines the thread ID for the calling thread. The ID is the same value as was returned
by glfw::CreateThread when the thread was created.


</pre></blockquote>

<!-- End of entry for GET-THREAD-ID -->


<!-- Entry for GET-TIME -->

<p><br>[Function]<br><a class=none name='get-time'><b>get-time</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Return values
The function returns the value of the high precision timer. The time is measured in seconds, and is
returned as a double precision floating point value.

Description
The function returns the state of a high precision timer. Unless the timer has been set by the
glfw::SetTime function, the time is measured as the number of seconds that have passed since glfw::Init
was called.

Notes
The resolution of the timer depends on which system the program is running on. The worst case
resolution is somewhere in the order of 10 ms, while for most systems the resolution should be better
than 1 μs.


</pre></blockquote>

<!-- End of entry for GET-TIME -->


<!-- Entry for GET-VERSION -->

<p><br>[Function]<br><a class=none name='get-version'><b>get-version</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Return values
The function returns the major and minor version numbers and the revision for the currently linked
GLFW library as a list (major minor rev).

</pre></blockquote>

<!-- End of entry for GET-VERSION -->


<!-- Entry for GET-VIDEO-MODES -->

<p><br>[Function]<br><a class=none name='get-video-modes'><b>get-video-modes</b> <i>maxcount</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
maxcount
      Maximum number of video modes that list vector can hold.

Return values
The function returns the number of detected video modes (this number will never exceed maxcount).
The list vector is filled out with the video modes that are supported by the system.

Description
The function returns a list of supported video modes. Each video mode is represented by a
list of the form:
(width height redbits greenbits bluebits)

Notes
The returned list is sorted, first by color depth (RedBits + GreenBits + BlueBits), and then by
resolution (Width × Height), with the lowest resolution, fewest bits per pixel mode first. 

</pre></blockquote>

<!-- End of entry for GET-VIDEO-MODES -->


<!-- Entry for GET-WINDOW-PARAM -->

<p><br>[Function]<br><a class=none name='get-window-param'><b>get-window-param</b> <i>param</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
param
      A token selecting which parameter the function should return (see table 3.2).

Return values
The function returns different parameters depending on the value of param. Table 3.2 lists valid param
values, and their corresponding return values.

Description
The function is used for acquiring various properties of an opened window.

Notes
+ACCELERATED+ is only supported under Windows. Other systems will always return
GL::+TRUE+. Under Windows, +ACCELERATED+ means that the OpenGL™ renderer is a 3rd
party renderer, rather than the fallback Microsoft software OpenGL™ renderer. In other words, it is
not a real guarantee that the OpenGL™ renderer is actually hardware accelerated.


</pre></blockquote>

<!-- End of entry for GET-WINDOW-PARAM -->


<!-- Entry for GET-WINDOW-SIZE -->

<p><br>[Function]<br><a class=none name='get-window-size'><b>get-window-size</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

The function is used for determining the size of an opened window. The returned values are dimensions
of the client area of the window (i.e. excluding any window borders and decorations).
(list width height)

</pre></blockquote>

<!-- End of entry for GET-WINDOW-SIZE -->


<!-- Entry for ICONIFY-WINDOW -->

<p><br>[Function]<br><a class=none name='iconify-window'><b>iconify-window</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Iconify a window. If the window is in fullscreen mode, then the desktop video mode will be restored.

</pre></blockquote>

<!-- End of entry for ICONIFY-WINDOW -->


<!-- Entry for INIT -->

<p><br>[Function]<br><a class=none name='init'><b>init</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Return values
If the function succeeds, t is returned.
If the function fails, nil is returned.

The glfwInit function initializes GLFW. No other GLFW functions may be used before this function
has been called.

Notes
This function may take several seconds to complete on some systems, while on other systems it may
take only a fraction of a second to complete.

</pre></blockquote>

<!-- End of entry for INIT -->


<!-- Entry for LOAD-MEMORY-TEXTURE-2D -->

<p><br>[Function]<br><a class=none name='load-memory-texture-2d'><b>load-memory-texture-2d</b> <i>data size flags</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
data
       The memory buffer holding the contents of the file that should be loaded.
size
       The size, in bytes, of the memory buffer.
flags
       Flags for controlling the texture loading process. Valid flags are listed in table 3.7.
Return values
The function returns t if the texture was loaded successfully. Otherwise nil is
returned.

Description
The function reads an image from the memory buffer specified by the parameter data and uploads the
image to OpenGL™ texture memory (using the glTexImage2D function).
If the +BUILD_MIPMAPS_BIT+ flag is set, all mipmap levels for the loaded texture are
generated and uploaded to texture memory.
Unless the flag +ORIGIN_UL_BIT+ is set, the origin of the texture is the lower left corner of the
loaded image. If the flag +ORIGIN_UL_BIT+ is set, however, the first pixel is the upper left
corner.
For single component images (i.e. gray scale), the texture is uploaded as an alpha mask if the flag
+ALPHA_MAP_BIT+ flag is set, otherwise it is uploaded as a luminance texture.

Notes
glfw::LoadMemoryTexture2D supports the Truevision Targa version 1 file format (.TGA). Supported
pixel formats are: 8-bit gray scale, 8-bit paletted (24/32-bit color), 24-bit true color and 32-bit true color
+ alpha.
Paletted images are translated into true color or true color + alpha pixel formats.
The read texture is always rescaled to the nearest larger 2m × 2n resolution using bilinear interpolation,
if necessary, since OpenGL™ requires textures to have a 2m × 2n resolution.
If the GL_SGIS_generate_mipmap extension, which is usually hardware accelerated, is supported by
the OpenGL™ implementation it will be used for mipmap generation. Otherwise the mipmaps will be
generated by GLFW in software.
Since OpenGL™ 1.0 does not support single component alpha maps, alpha map textures are converted
to RGBA format under OpenGL™ 1.0 when the +ALPHA_MAP_BIT+ flag is set and the loaded
texture is a single component texture. The red, green and blue components are set to 1.0.


</pre></blockquote>

<!-- End of entry for LOAD-MEMORY-TEXTURE-2D -->


<!-- Entry for LOAD-TEXTURE-2D -->

<p><br>[Function]<br><a class=none name='load-texture-2d'><b>load-texture-2d</b> <i>name flags</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
name
       An ISO 8859-1 string holding the name of the file that should be loaded.
flags
       Flags for controlling the texture loading process. Valid flags are listed in table 3.7.
Return values
The function returns t if the texture was loaded successfully. Otherwise nil is
returned.

Description
The function reads an image from the file specified by the parameter name and uploads the image to
OpenGL™ texture memory (using the glTexImage2D function).
If the +BUILD_MIPMAPS_BIT+ flag is set, all mipmap levels for the loaded texture are
generated and uploaded to texture memory.
Unless the flag +ORIGIN_UL_BIT+ is set, the origin of the texture is the lower left corner of the
loaded image. If the flag +ORIGIN_UL_BIT+ is set, however, the first pixel is the upper left
corner.
For single component images (i.e. gray scale), the texture is uploaded as an alpha mask if the flag
+ALPHA_MAP_BIT+ flag is set, otherwise it is uploaded as a luminance texture.

Notes
glfw::LoadTexture2D supports the Truevision Targa version 1 file format (.TGA). Supported pixel
formats are: 8-bit gray scale, 8-bit paletted (24/32-bit color), 24-bit true color and 32-bit true color +
alpha.
Paletted images are translated into true color or true color + alpha pixel formats.
The read texture is always rescaled to the nearest larger 2m × 2n resolution using bilinear interpolation,
if necessary, since OpenGL™ requires textures to have a 2m × 2n resolution.
If the GL_SGIS_generate_mipmap extension, which is usually hardware accelerated, is supported by
the OpenGL™ implementation it will be used for mipmap generation. Otherwise the mipmaps will be
generated by GLFW in software.
Since OpenGL™ 1.0 does not support single component alpha maps, alpha map textures are converted
to RGBA format under OpenGL™ 1.0 when the +ALPHA_MAP_BIT+ flag is set and the loaded
texture is a single component texture. The red, green and blue components are set to 1.0.


</pre></blockquote>

<!-- End of entry for LOAD-TEXTURE-2D -->


<!-- Entry for LOAD-TEXTURE-IMAGE-2D -->

<p><br>[Function]<br><a class=none name='load-texture-image-2d'><b>load-texture-image-2d</b> <i>img flags</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
img
      Pointer to a GLFWimage struct holding the information about the image to be loaded.
flags
      Flags for controlling the texture loading process. Valid flags are listed in table 3.7.
Return values
The function returns t if the texture was loaded successfully. Otherwise nil is
returned.

Description
The function uploads the image specified by the parameter img to OpenGL™ texture memory (using
the glTexImage2D function).
If the +BUILD_MIPMAPS_BIT+ flag is set, all mipmap levels for the loaded texture are
generated and uploaded to texture memory.
Unless the flag +ORIGIN_UL_BIT+ is set, the origin of the texture is the lower left corner of the
loaded image. If the flag +ORIGIN_UL_BIT+ is set, however, the first pixel is the upper left
corner.
For single component images (i.e. gray scale), the texture is uploaded as an alpha mask if the flag
+ALPHA_MAP_BIT+ flag is set, otherwise it is uploaded as a luminance texture.

Notes
glfw::LoadTextureImage2D supports the Truevision Targa version 1 file format (.TGA). Supported
pixel formats are: 8-bit gray scale, 8-bit paletted (24/32-bit color), 24-bit true color and 32-bit true color
+ alpha.
Paletted images are translated into true color or true color + alpha pixel formats.
The read texture is always rescaled to the nearest larger 2m × 2n resolution using bilinear interpolation,
if necessary, since OpenGL™ requires textures to have a 2m × 2n resolution.
If the GL_SGIS_generate_mipmap extension, which is usually hardware accelerated, is supported by
the OpenGL™ implementation it will be used for mipmap generation. Otherwise the mipmaps will be
generated by GLFW in software.
Since OpenGL™ 1.0 does not support single component alpha maps, alpha map textures are converted
to RGBA format under OpenGL™ 1.0 when the +ALPHA_MAP_BIT+ flag is set and the loaded
texture is a single component texture. The red, green and blue components are set to 1.0. 

</pre></blockquote>

<!-- End of entry for LOAD-TEXTURE-IMAGE-2D -->


<!-- Entry for LOCK-MUTEX -->

<p><br>[Function]<br><a class=none name='lock-mutex'><b>lock-mutex</b> <i>mutex</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
mutex
      A mutex object handle.
Description
The function will acquire a lock on the selected mutex object. If the mutex is already locked by another
thread, the function will block the calling thread until it is released by the locking thread. Once the
function returns, the calling thread has an exclusive lock on the mutex. To release the mutex, call
glfw::UnlockMutex.


</pre></blockquote>

<!-- End of entry for LOCK-MUTEX -->


<!-- Entry for OPEN-WINDOW -->

<p><br>[Function]<br><a class=none name='open-window'><b>open-window</b> <i><tt>&amp;optional</tt> width height redbits greenbits bluebits alphabits depthbits stencilbits mode</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

width
      The width of the window. If width is zero, it will be calculated as width = 4/3 height, if height is
      not zero. If both width and height are zero, then width will be set to 640.
height
      The height of the window. If height is zero, it will be calculated as height = 3/4 width, if width is
      not zero. If both width and height are zero, then height will be set to 480.
redbits, greenbits, bluebits
      The number of bits to use for each color component of the color buffer (0 means default color
      depth). For instance, setting redbits=5, greenbits=6, and bluebits=5 will generate a 16-bit color
      buffer, if possible.
alphabits
      The number of bits to use for the alpha buffer (0 means no alpha buffer).
depthbits
      The number of bits to use for the depth buffer (0 means no depth buffer).
stencilbits
      The number of bits to use for the stencil buffer (0 means no stencil buffer).
mode
      Selects which type of OpenGL™ window to use. mode can be either +WINDOW+, which
      will generate a normal desktop window, or +FULLSCREEN+ which will generate a
      window which covers the entire screen. When +FULLSCREEN+ is selected, the video
      mode will be changed to the resolution that closest matches the width and height parameters.

Return values
If the function succeeds, t is returned.
If the function fails, nil is returned.

Description
The function opens a window that best matches the parameters given to the function. How well the
resulting window matches the desired window depends mostly on the available hardware and
OpenGL™ drivers. In general, selecting a fullscreen mode has better chances of generating a close
match than does a normal desktop window, since GLFW can freely select from all the available video
modes. A desktop window is normally restricted to the video mode of the desktop.

Notes
For additional control of window properties, see glfw::OpenWindowHint.
In fullscreen mode the mouse cursor is hidden by default, and any system screensavers are prohibited
from starting. In windowed mode the mouse cursor is visible, and screensavers are allowed to start. To
change the visibility of the mouse cursor, use glfwEnable or glfwDisable with the argument
+MOUSE_CURSOR+
In order to determine the actual properties of an opened window, use glfw::GetWindowParam and
glfw::GetWindowSize (or glfw::SetWindowSizeCallback).


</pre></blockquote>

<!-- End of entry for OPEN-WINDOW -->


<!-- Entry for OPEN-WINDOW-HINT -->

<p><br>[Function]<br><a class=none name='open-window-hint'><b>open-window-hint</b> <i>target hint</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

target
       Can be any of the constants in the table 3.1.
hint
       An integer giving the value of the corresponding target (see table 3.1).

Description
The function sets additional properties for a window that is to be opened. For a hint to be registered, the
function must be called before calling glfw::OpenWindow. When the glfw::OpenWindow function is
called, any hints that were registered with the glfw::OpenWindowHint function are used for setting the
corresponding window properties, and then all hints are reset to their default values.

Notes
In order to determine the actual properties of an opened window, use glfw::GetWindowParam (after the
window has been opened).
+STEREO+ is a hard constraint. If stereo rendering is requested, but no stereo rendering capable
pixel formats / visuals are available, glfw::OpenWindow will fail.
The +REFRESH_RATE+ property should be used with caution. Most systems have default values
for monitor refresh rates that are optimal for the specific system. Specifying the refresh rate can
override these settings, which can result in suboptimal operation. The monitor may be unable to display
the resulting video signal, or in the worst case it may even be damaged!


</pre></blockquote>

<!-- End of entry for OPEN-WINDOW-HINT -->


<!-- Entry for POLL-EVENTS -->

<p><br>[Function]<br><a class=none name='poll-events'><b>poll-events</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Description
The function is used for polling for events, such as user input and window resize events. Upon calling
this function, all window states, keyboard states and mouse states are updated. If any related callback
functions are registered, these are called during the call to glfwPollEvents.

Notes
glfwPollEvents is called implicitly from glfwSwapBuffers if +AUTO_POLL_EVENTS+ is
enabled (default). Thus, if glfwSwapBuffers is called frequently, which is normally the case, there is
no need to call glfwPollEvents.


</pre></blockquote>

<!-- End of entry for POLL-EVENTS -->


<!-- Entry for READ-IMAGE -->

<p><br>[Function]<br><a class=none name='read-image'><b>read-image</b> <i>name img flags</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
name
      A null terminated ISO 8859-1 string holding the name of the file that should be read.
img
      Pointer to a GLFWimage struct, which will hold the information about the loaded image (if the
      read was successful).
flags
      Flags for controlling the image reading process. Valid flags are listed in table 3.6
Return values
The function returns t if the image was loaded successfully. Otherwise nil is
returned.
Description
The function reads an image from the file specified by the parameter name and returns the image
information and data in a GLFWimage structure, which has the following definition:
§                                                                                                    ¤
typedef struct {
      int Width, Height;                 //   Image dimensions
      int Format;                        //   OpenGL pixel format
      int BytesPerPixel;                 //   Number of bytes per pixel
      unsigned char *Data;               //   Pointer to pixel data
} GLFWimage;
¦                                                                                                    ¥
Width and Height give the dimensions of the image. Format specifies an OpenGL™ pixel format,
which can be GL_LUMINANCE or GL_ALPHA (for gray scale images), GL_RGB or GL_RGBA.
BytesPerPixel specifies the number of bytes per pixel. Data is a pointer to the actual pixel data.
By default the read image is rescaled to the nearest larger 2m × 2n resolution using bilinear
interpolation, if necessary, which is useful if the image is to be used as an OpenGL™ texture. This
behavior can be disabled by setting the +NO_RESCALE_BIT+ flag.
Unless the flag +ORIGIN_UL_BIT+ is set, the first pixel in img-&gt;Data is the lower left corner of
the image. If the flag +ORIGIN_UL_BIT+ is set, however, the first pixel is the upper left corner.
For single component images (i.e. gray scale), Format is set to GL_ALPHA if the flag
+ALPHA_MAP_BIT+ flag is set, otherwise Format is set to GL_LUMINANCE.
Notes
glfw::ReadImage supports the Truevision Targa version 1 file format (.TGA). Supported pixel formats
are: 8-bit gray scale, 8-bit paletted (24/32-bit color), 24-bit true color and 32-bit true color + alpha.
Paletted images are translated into true color or true color + alpha pixel formats.
Please note that OpenGL™ 1.0 does not support single component alpha maps, so do not use images
with Format = GL_ALPHA directly as textures under OpenGL™ 1.0.


</pre></blockquote>

<!-- End of entry for READ-IMAGE -->


<!-- Entry for READ-MEMORY-IMAGE -->

<p><br>[Function]<br><a class=none name='read-memory-image'><b>read-memory-image</b> <i>data size img flags</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
data
      The memory buffer holding the contents of the file that should be read.
size
      The size, in bytes, of the memory buffer.
img
      Pointer to a GLFWimage struct, which will hold the information about the loaded image (if the
      read was successful).
flags
      Flags for controlling the image reading process. Valid flags are listed in table 3.6
Return values
The function returns t if the image was loaded successfully. Otherwise nil is
returned.
Description
The function reads an image from the memory buffer specified by the parameter data and returns the
image information and data in a GLFWimage structure, which has the following definition:
§                                                                                                            ¤
typedef struct {
      int Width, Height;                 //   Image dimensions
      int Format;                        //   OpenGL pixel format
      int BytesPerPixel;                 //   Number of bytes per pixel
      unsigned char *Data;               //   Pointer to pixel data
} GLFWimage;
¦                                                                                                            ¥
Width and Height give the dimensions of the image. Format specifies an OpenGL™ pixel format,
which can be GL_LUMINANCE or GL_ALPHA (for gray scale images), GL_RGB or GL_RGBA.
BytesPerPixel specifies the number of bytes per pixel. Data is a pointer to the actual pixel data.
By default the read image is rescaled to the nearest larger 2m × 2n resolution using bilinear
interpolation, if necessary, which is useful if the image is to be used as an OpenGL™ texture. This
behavior can be disabled by setting the +NO_RESCALE_BIT+ flag.
Unless the flag +ORIGIN_UL_BIT+ is set, the first pixel in img-&gt;Data is the lower left corner of
the image. If the flag +ORIGIN_UL_BIT+ is set, however, the first pixel is the upper left corner.
For single component images (i.e. gray scale), Format is set to GL_ALPHA if the flag
+ALPHA_MAP_BIT+ flag is set, otherwise Format is set to GL_LUMINANCE.
Notes
glfw::ReadMemoryImage supports the Truevision Targa version 1 file format (.TGA). Supported pixel
formats are: 8-bit gray scale, 8-bit paletted (24/32-bit color), 24-bit true color and 32-bit true color +
alpha.
Paletted images are translated into true color or true color + alpha pixel formats.
Please note that OpenGL™ 1.0 does not support single component alpha maps, so do not use images
with Format = GL_ALPHA directly as textures under OpenGL™ 1.0.


</pre></blockquote>

<!-- End of entry for READ-MEMORY-IMAGE -->


<!-- Entry for RESTORE-WINDOW -->

<p><br>[Function]<br><a class=none name='restore-window'><b>restore-window</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Restore an iconified window. If the window that is restored is in fullscreen mode, then the fullscreen
video mode will be restored.

</pre></blockquote>

<!-- End of entry for RESTORE-WINDOW -->


<!-- Entry for SET-CHAR-CALLBACK -->

<p><br>[Function]<br><a class=none name='set-char-callback'><b>set-char-callback</b> <i>cbfun</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
cbfun
       Pointer to a callback function that will be called every time a printable character is generated by
       the keyboard. The function should have the following C language prototype:
       void GLFWCALL functionname( int character, int action );
       Where functionname is the name of the callback function, character is a Unicode (ISO 10646)
       character, and action is either +PRESS+ or +RELEASE+
       If cbfun is NULL, any previously selected callback function will be deselected.
Return values
none
Description
The function selects which function to be called upon a keyboard character event. The callback function
is called every time a key that results in a printable Unicode character is pressed or released. Characters
are affected by modifiers (such as shift or alt).
A window has to be opened for this function to have any effect.
Notes
Character events are recorded continuously, but only reported when glfw::PollEvents, glfw::WaitEvents
or glfw::SwapBuffers is called.
Control characters, such as tab and carriage return, are not reported to the character callback function,
since they are not part of the Unicode character set. Use the key callback function for such events (see
glfw::SetKeyCallback).
The Unicode character set supports character codes above 255, so never cast a Unicode character to an
eight bit data type (e.g. the C language ’char’ type) without first checking that the character code is less
than 256. Also note that Unicode character codes 0 to 255 are equal to ISO 8859-1 (Latin 1).


</pre></blockquote>

<!-- End of entry for SET-CHAR-CALLBACK -->


<!-- Entry for SET-KEY-CALLBACK -->

<p><br>[Function]<br><a class=none name='set-key-callback'><b>set-key-callback</b> <i>cbfun</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
cbfun
      Pointer to a callback function that will be called every time a key is pressed or released. The
      function should have the following C language prototype:
      void GLFWCALL functionname( int key, int action );
      Where functionname is the name of the callback function, key is a key identifier, which is an
      uppercase printable ISO 8859-1 character or a special key identifier (see table 3.3), and action is
      either +PRESS+ or +RELEASE+
      If cbfun is NULL, any previously selected callback function will be deselected.
Return values
none
Description
The function selects which function to be called upon a keyboard key event. The callback function is
called every time the state of a single key is changed (from released to pressed or vice versa). The
reported keys are unaffected by any modifiers (such as shift or alt).
A window has to be opened for this function to have any effect.
Notes
Keyboard events are recorded continuously, but only reported when glfw::PollEvents, glfw::WaitEvents
or glfw::SwapBuffers is called.


</pre></blockquote>

<!-- End of entry for SET-KEY-CALLBACK -->


<!-- Entry for SET-MOUSE-BUTTON-CALLBACK -->

<p><br>[Function]<br><a class=none name='set-mouse-button-callback'><b>set-mouse-button-callback</b> <i>cbfun</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
cbfun
      Pointer to a callback function that will be called every time a mouse button is pressed or released.
      The function should have the following C language prototype:
      void GLFWCALL functionname( int button, int action );
      Where functionname is the name of the callback function, button is a mouse button identifier (see
      table 3.4 on page 56), and action is either +PRESS+ or +RELEASE+
      If cbfun is NULL, any previously selected callback function will be deselected.
Return values
none
Description
The function selects which function to be called upon a mouse button event.
A window has to be opened for this function to have any effect.
Notes
Mouse button events are recorded continuously, but only reported when glfw::PollEvents,
glfw::WaitEvents or glfw::SwapBuffers is called.
+MOUSE_BUTTON_LEFT+ is equal to +MOUSE_BUTTON_1+
+MOUSE_BUTTON_RIGHT+ is equal to +MOUSE_BUTTON_2+
+MOUSE_BUTTON_MIDDLE+ is equal to +MOUSE_BUTTON_3+


</pre></blockquote>

<!-- End of entry for SET-MOUSE-BUTTON-CALLBACK -->


<!-- Entry for SET-MOUSE-POS -->

<p><br>[Function]<br><a class=none name='set-mouse-pos'><b>set-mouse-pos</b> <i>xpos ypos</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
xpos
     Horizontal position of the mouse.
ypos
     Vertical position of the mouse.

Description
The function changes the position of the mouse. If the cursor is visible (not disabled), the cursor will be
moved to the specified position, relative to the upper left corner of the window client area. If the cursor
is hidden (disabled), only the mouse position that is reported by GLFW is changed.


</pre></blockquote>

<!-- End of entry for SET-MOUSE-POS -->


<!-- Entry for SET-MOUSE-POS-CALLBACK -->

<p><br>[Function]<br><a class=none name='set-mouse-pos-callback'><b>set-mouse-pos-callback</b> <i>cbfun</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
cbfun
      Pointer to a callback function that will be called every time the mouse is moved. The function
      should have the following C language prototype:
      void GLFWCALL functionname( int x, int y );
      Where functionname is the name of the callback function, and x and y are the mouse coordinates
      (see glfw::GetMousePos for more information on mouse coordinates).
      If cbfun is NULL, any previously selected callback function will be deselected.
Return values
none
Description
The function selects which function to be called upon a mouse motion event.
A window has to be opened for this function to have any effect.
Notes
Mouse motion events are recorded continuously, but only reported when glfw::PollEvents,
glfw::WaitEvents or glfw::SwapBuffers is called.


</pre></blockquote>

<!-- End of entry for SET-MOUSE-POS-CALLBACK -->


<!-- Entry for SET-MOUSE-WHEEL -->

<p><br>[Function]<br><a class=none name='set-mouse-wheel'><b>set-mouse-wheel</b> <i>pos</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
pos
     Position of the mouse wheel.
Description
The function changes the position of the mouse wheel.


</pre></blockquote>

<!-- End of entry for SET-MOUSE-WHEEL -->


<!-- Entry for SET-MOUSE-WHEEL-CALLBACK -->

<p><br>[Function]<br><a class=none name='set-mouse-wheel-callback'><b>set-mouse-wheel-callback</b> <i>cbfun</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
cbfun
      Pointer to a callback function that will be called every time the mouse wheel is moved. The
      function should have the following C language prototype:
      void GLFWCALL functionname( int pos );
      Where functionname is the name of the callback function, and pos is the mouse wheel position.
      If cbfun is NULL, any previously selected callback function will be deselected.
Return values
none
Description
The function selects which function to be called upon a mouse wheel event.
A window has to be opened for this function to have any effect.
Notes
Mouse wheel events are recorded continuously, but only reported when glfw::PollEvents,
glfw::WaitEvents or glfw::SwapBuffers is called.


</pre></blockquote>

<!-- End of entry for SET-MOUSE-WHEEL-CALLBACK -->


<!-- Entry for SET-TIME -->

<p><br>[Function]<br><a class=none name='set-time'><b>set-time</b> <i>time</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
time
      Time (in seconds) that the timer should be set to.

Description
The function sets the current time of the high precision timer to the specified time. Subsequent calls to
glfw::GetTime will be relative to this time. The time is given in seconds.


</pre></blockquote>

<!-- End of entry for SET-TIME -->


<!-- Entry for SET-WINDOW-CLOSE-CALLBACK -->

<p><br>[Function]<br><a class=none name='set-window-close-callback'><b>set-window-close-callback</b> <i>cbfun</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
cbfun
      Pointer to a callback function that will be called when a user requests that the window should be
      closed, typically by clicking the window close icon (e.g. the cross in the upper right corner of a
      window under Microsoft Windows). The function should have the following C language
      prototype:
      int GLFWCALL functionname( void );
      Where functionname is the name of the callback function. The return value of the callback
      function indicates wether or not the window close action should continue. If the function returns
      GL_TRUE, the window will be closed. If the function returns GL_FALSE, the window will not
      be closed.
      If cbfun is NULL, any previously selected callback function will be deselected.

      If you declare your callback as returning glfw:boolean, you can use t and nil as return types.

Description
The function selects which function to be called upon a window close event.
A window has to be opened for this function to have any effect.

Notes
Window close events are recorded continuously, but only reported when glfwPollEvents,
glfwWaitEvents or glfwSwapBuffers is called.
The OpenGL™ context is still valid when this function is called.
Note that the window close callback function is not called when glfwCloseWindow is called, but only
when the close request comes from the window manager.
Do not call glfwCloseWindow from a window close callback function. Close the window by returning
GL_TRUE from the function.


</pre></blockquote>

<!-- End of entry for SET-WINDOW-CLOSE-CALLBACK -->


<!-- Entry for SET-WINDOW-POS -->

<p><br>[Function]<br><a class=none name='set-window-pos'><b>set-window-pos</b> <i>x y</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
x
      Horizontal position of the window, relative to the upper left corner of the desktop.
y
      Vertical position of the window, relative to the upper left corner of the desktop.
Return values
none
Description
The function changes the position of an opened window. It does not have any effect on a fullscreen
window.


</pre></blockquote>

<!-- End of entry for SET-WINDOW-POS -->


<!-- Entry for SET-WINDOW-REFRESH-CALLBACK -->

<p><br>[Function]<br><a class=none name='set-window-refresh-callback'><b>set-window-refresh-callback</b> <i>cbfun</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
cbfun
       Pointer to a callback function that will be called when the window client area needs to be
       refreshed. The function should have the following CFFI  prototype:
       (cffi:defcallback callback-name :void ((width :int) (height :int)) .. body ..)
       Where callback is the name of the callback function.
       If cbfun is the null-pointer, any previously selected callback function will be deselected.

Description
The function selects which function to be called upon a window refresh event, which occurs when any
part of the window client area has been damaged, and needs to be repainted (for instance, if a part of the
window that was previously occluded by another window has become visible).
A window has to be opened for this function to have any effect.

Notes
Window refresh events are recorded continuously, but only reported when glfwPollEvents,
glfwWaitEvents or glfwSwapBuffers is called.


</pre></blockquote>

<!-- End of entry for SET-WINDOW-REFRESH-CALLBACK -->


<!-- Entry for SET-WINDOW-SIZE -->

<p><br>[Function]<br><a class=none name='set-window-size'><b>set-window-size</b> <i>width height</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
width
       Width of the window.
height
       Height of the window.
Return values
none
Description
The function changes the size of an opened window. The width and height parameters denote the size of
the client area of the window (i.e. excluding any window borders and decorations).
If the window is in fullscreen mode, the video mode will be changed to a resolution that closest matches
the width and height parameters (the number of color bits will not be changed).
Notes
The OpenGL™ context is guaranteed to be preserved after calling glfwSetWindowSize, even if the
video mode is changed.


</pre></blockquote>

<!-- End of entry for SET-WINDOW-SIZE -->


<!-- Entry for SET-WINDOW-SIZE-CALLBACK -->

<p><br>[Function]<br><a class=none name='set-window-size-callback'><b>set-window-size-callback</b> <i>cbfun</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
cbfun
      Pointer to a callback function that will be called every time the window size changes. The
      function should have the following C language prototype:
      void GLFWCALL functionname( int width, int height );
      Where functionname is the name of the callback function, and width and height are the
      dimensions of the window client area.
      If cbfun is NULL, any previously selected callback function will be deselected.
Return values
none
Description
The function selects which function to be called upon a window size change event.
A window has to be opened for this function to have any effect.
Notes
Window size changes are recorded continuously, but only reported when glfwPollEvents,
glfwWaitEvents or glfwSwapBuffers is called. 

</pre></blockquote>

<!-- End of entry for SET-WINDOW-SIZE-CALLBACK -->


<!-- Entry for SET-WINDOW-TITLE -->

<p><br>[Function]<br><a class=none name='set-window-title'><b>set-window-title</b> <i>title</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
title
       Pointer to a null terminated ISO 8859-1 (8-bit Latin 1) string that holds the title of the window.

Description
The function changes the title of the opened window.

Notes
The title property of a window is often used in situations other than for the window title, such as the title
of an application icon when it is in iconified state.

</pre></blockquote>

<!-- End of entry for SET-WINDOW-TITLE -->


<!-- Entry for SIGNAL-COND -->

<p><br>[Function]<br><a class=none name='signal-cond'><b>signal-cond</b> <i>cond</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
cond
       A condition variable object handle.
Description
The function restarts one of the threads that are waiting on the condition variable cond. If no threads are
waiting on cond, nothing happens. If several threads are waiting on cond, exactly one is restarted, but it
is not specified which.
Notes
When several threads are waiting for the condition variable, which thread is started depends on
operating system scheduling rules, and may vary from system to system and from time to time.


</pre></blockquote>

<!-- End of entry for SIGNAL-COND -->


<!-- Entry for SLEEP -->

<p><br>[Function]<br><a class=none name='sleep'><b>sleep</b> <i>time</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
time
        Time, in seconds, to sleep.

Description
The function puts the calling thread to sleep for the requested period of time. Only the calling thread is
put to sleep. Other threads within the same process can still execute.

Notes
There is usually a system dependent minimum time for which it is possible to sleep. This time is
generally in the range 1 ms to 20 ms, depending on thread sheduling time slot intervals etc. Using a
shorter time as a parameter to glfw::Sleep can give one of two results: either the thread will sleep for the
minimum possible sleep time, or the thread will not sleep at all (glfw::Sleep returns immediately). The
latter should only happen when very short sleep times are specified, if at all. 

</pre></blockquote>

<!-- End of entry for SLEEP -->


<!-- Entry for SWAP-BUFFERS -->

<p><br>[Function]<br><a class=none name='swap-buffers'><b>swap-buffers</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

The function swaps the back and front color buffers of the window. If +AUTO_POLL_EVENTS+
is enabled (which is the default), glfwPollEvents is called before swapping the front and back buffers.

</pre></blockquote>

<!-- End of entry for SWAP-BUFFERS -->


<!-- Entry for SWAP-INTERVAL -->

<p><br>[Function]<br><a class=none name='swap-interval'><b>swap-interval</b> <i>interval</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
interval
      Minimum number of monitor vertical retraces between each buffer swap performed by
      glfwSwapBuffers. If interval is zero, buffer swaps will not be synchronized to the vertical
      refresh of the monitor (also known as ’VSync off’).

Description
The function selects the minimum number of monitor vertical retraces that should occur between two
buffer swaps. If the selected swap interval is one, the rate of buffer swaps will never be higher than the
vertical refresh rate of the monitor. If the selected swap interval is zero, the rate of buffer swaps is only
limited by the speed of the software and the hardware.

Notes
This function will only have an effect on hardware and drivers that support user selection of the swap
interval. 

</pre></blockquote>

<!-- End of entry for SWAP-INTERVAL -->


<!-- Entry for TERMINATE -->

<p><br>[Function]<br><a class=none name='terminate'><b>terminate</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

The function terminates GLFW. Among other things it closes the window, if it is opened, and kills any
running threads. This function must be called before a program exits.

</pre></blockquote>

<!-- End of entry for TERMINATE -->


<!-- Entry for UNLOCK-MUTEX -->

<p><br>[Function]<br><a class=none name='unlock-mutex'><b>unlock-mutex</b> <i>mutex</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
mutex
      A mutex object handle.
Description
The function releases the lock of a locked mutex object.


</pre></blockquote>

<!-- End of entry for UNLOCK-MUTEX -->


<!-- Entry for WAIT-COND -->

<p><br>[Function]<br><a class=none name='wait-cond'><b>wait-cond</b> <i>cond mutex timeout</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

  arameters
cond
       A condition variable object handle.
mutex
       A mutex object handle.
timeout
       Maximum time to wait for the condition variable. The parameter can either be a positive time (in
       seconds), or +INFINITY+
Description
The function atomically unlocks the mutex specified by mutex, and waits for the condition variable cond
to be signaled. The thread execution is suspended and does not consume any CPU time until the
condition variable is signaled or the amount of time specified by timeout has passed. If timeout is
+INFINITY+ glfw::WaitCond will wait forever for cond to be signaled. Before returning to the
calling thread, glfw::WaitCond automatically re-acquires the mutex.
Notes
The mutex specified by mutex must be locked by the calling thread before entrance to glfw::WaitCond.
A condition variable must always be associated with a mutex, to avoid the race condition where a thread
prepares to wait on a condition variable and another thread signals the condition just before the first
thread actually waits on it.


</pre></blockquote>

<!-- End of entry for WAIT-COND -->


<!-- Entry for WAIT-EVENTS -->

<p><br>[Function]<br><a class=none name='wait-events'><b>wait-events</b> <i></i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Description
The function is used for waiting for events, such as user input and window resize events. Upon calling
this function, the calling thread will be put to sleep until any event appears in the event queue. When
events are ready, the events will be processed just as they are processed by glfwPollEvents.
If there are any events in the queue when the function is called, the function will behave exactly like
glfwPollEvents (i.e. process all messages and then return, without blocking the calling thread).

Notes
It is guaranteed that glfwWaitEvents will wake up on any event that can be processed by
glfw::PollEvents. However, glfwWaitEvents may wake up on events that are not processed or reported
by glfw::PollEvents too, and the function may behave differently on different systems. Do no make any
assumptions about when or why glfw::WaitEvents will return.


</pre></blockquote>

<!-- End of entry for WAIT-EVENTS -->


<!-- Entry for WAIT-THREAD -->

<p><br>[Function]<br><a class=none name='wait-thread'><b>wait-thread</b> <i>id waitmode</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
ID
      A thread identification handle, which is returned by glfw::CreateThread or glfw::GetThreadID.
waitmode
      Can be either +WAIT+ or +NOWAIT+
Return values
The function returns t if the specified thread died after the function was called, or the thread
did not exist, in which case glfw::WaitThread will return immediately regardless of waitmode. The
function returns nil if waitmode is +NOWAIT+ and the specified thread exists and is still
running.


</pre></blockquote>

<!-- End of entry for WAIT-THREAD -->


<!-- Entry for WITH-INIT -->

<p><br>[Macro]<br><a class=none name='with-init'><b>with-init</b> <i>declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Call glfw:init, execute forms and clean-up with glfw:terminate once finished.
This makes a nice wrapper to an application higher-level form. 
Signals an error on failure to initialize. Wrapped in a block named glfw:with-init.

</pre></blockquote>

<!-- End of entry for WITH-INIT -->


<!-- Entry for WITH-INIT-WINDOW -->

<p><br>[Macro]<br><a class=none name='with-init-window'><b>with-init-window</b> <i>(<tt>&amp;optional</tt> title width height redbits greenbits bluebits alphabits depthbits stencilbits mode) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Wraps forms in with-init, with-open-window. Passes through the other arguments to open-window.

</pre></blockquote>

<!-- End of entry for WITH-INIT-WINDOW -->


<!-- Entry for WITH-LOCK-MUTEX -->

<p><br>[Macro]<br><a class=none name='with-lock-mutex'><b>with-lock-mutex</b> <i>mutex declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Parameters
mutex
      A mutex object handle.
forms
      Body of code to execute
Description
This macro will acquire a lock on the selected mutex object using glfw::LockMutex and release it afterwards
using glfw::UnlockMutex.
So, forms will not execute until an exclusive lock is held.
The lock is then released when the stack is unwound.

</pre></blockquote>

<!-- End of entry for WITH-LOCK-MUTEX -->


<!-- Entry for WITH-OPEN-WINDOW -->

<p><br>[Macro]<br><a class=none name='with-open-window'><b>with-open-window</b> <i>(<tt>&amp;optional</tt> title width height redbits greenbits bluebits alphabits depthbits stencilbits mode) declaration* statement*</i> =&gt; <i>result</i></a>
<blockquote><br><pre>

Wraps forms such that there is an open window for them to execute in and cleans up the
window afterwards. An error is signalled if there was an error opening the window.
Takes the same parameters as open-window, with the addition of &#039;title&#039; which will
set the window title after opening.
Wrapped in a block named glfw:with-open-window.

</pre></blockquote>

<!-- End of entry for WITH-OPEN-WINDOW -->


<br>&nbsp;<br><h3><a class=none name="ack">Acknowledgements</a></h3>

<p>
This documentation was prepared with <a href="http://weitz.de/documentation-template/">DOCUMENTATION-TEMPLATE</a>.
</p>
<p>
</body>
</html>